
// This file is automatically generated. Do not edit it directly.
import { faker } from '@faker-js/faker';

export interface Restaurant {
  id: string;
  name: string;
  description: string;
  cuisineType: string;
  imageUrl: string;
  address: string;
  phone: string;
  website: string;
  rating: number;
  reviewCount: number;
  costRating: number;
  openingHours: {
    [key: string]: {
      open: string;
      close: string;
    };
  };
  bookedToday: number;
  latitude: number;
  longitude: number;
}

export interface Review {
  id: string;
  restaurantId: string;
  userName: string;
  rating: number;
  date: string;
  comment: string;
}

// Set seed for reproducible data
faker.seed(123);

// Generate a list of restaurants
const generateRestaurants = (): Restaurant[] => {
  const cuisineTypes = [
    'Italian',
    'Japanese',
    'Chinese',
    'Mexican',
    'French',
    'Indian',
    'Thai',
    'American',
    'Mediterranean',
    'Greek',
    'Spanish',
    'Lebanese',
    'Korean',
    'Vietnamese',
    'Brazilian',
    'German',
    'British'
  ];

  return Array.from({ length: 20 }, (_, index) => {
    const latitude = 34.05 + (Math.random() - 0.5) * 0.1;
    const longitude = -118.25 + (Math.random() - 0.5) * 0.1;
    const cuisineType = cuisineTypes[Math.floor(Math.random() * cuisineTypes.length)];
    
    return {
      id: `rest-${index + 1}`,
      name: index < 5 
        ? ['La Bella Italia', 'Sakura Sushi', 'El Mariachi', 'Le Petit Bistro', 'Taj Mahal'][index] 
        : faker.company.name() + ' ' + (Math.random() > 0.5 ? 'Restaurant' : 'Bistro'),
      description: faker.lorem.paragraph(),
      cuisineType,
      imageUrl: `https://source.unsplash.com/random/800x600/?${cuisineType.toLowerCase()},restaurant&sig=${index}`,
      address: faker.location.streetAddress() + ', ' + faker.location.city(),
      phone: faker.phone.number(),
      website: 'https://www.' + faker.internet.domainName(),
      rating: Number((3 + Math.random() * 2).toFixed(1)),
      reviewCount: Math.floor(10 + Math.random() * 490),
      costRating: Math.floor(1 + Math.random() * 4),
      openingHours: {
        monday: { open: '11:00', close: '22:00' },
        tuesday: { open: '11:00', close: '22:00' },
        wednesday: { open: '11:00', close: '22:00' },
        thursday: { open: '11:00', close: '22:00' },
        friday: { open: '11:00', close: '23:00' },
        saturday: { open: '10:00', close: '23:00' },
        sunday: { open: '10:00', close: '21:00' },
      },
      bookedToday: Math.floor(Math.random() * 20),
      latitude,
      longitude,
    };
  });
};

const generateReviews = (restaurants: Restaurant[]): Review[] => {
  const reviews: Review[] = [];
  
  restaurants.forEach(restaurant => {
    const reviewCount = Math.floor(5 + Math.random() * 15);
    
    for (let i = 0; i < reviewCount; i++) {
      reviews.push({
        id: `review-${restaurant.id}-${i}`,
        restaurantId: restaurant.id,
        userName: faker.person.fullName(),
        rating: Math.floor(1 + Math.random() * 5),
        date: faker.date.recent(365).toISOString().split('T')[0],
        comment: faker.lorem.paragraph(),
      });
    }
  });
  
  return reviews;
};

// Create the restaurants and reviews data
const restaurants = generateRestaurants();
const reviews = generateReviews(restaurants);

// Get restaurant by ID
export const getRestaurantById = (id: string): Restaurant | null => {
  return restaurants.find(restaurant => restaurant.id === id) || null;
};

// Get reviews for a restaurant
export const getReviewsForRestaurant = (restaurantId: string): Review[] => {
  return reviews.filter(review => review.restaurantId === restaurantId);
};

// Get restaurants by search criteria
export const getRestaurantsByAvailability = (
  date: string,
  time: string,
  partySize: number,
  location: string = ''
): Restaurant[] => {
  // Filter restaurants by location if provided
  let filteredRestaurants = restaurants;
  
  if (location && location.trim() !== '') {
    const locationLower = location.toLowerCase();
    filteredRestaurants = restaurants.filter(restaurant => 
      restaurant.address.toLowerCase().includes(locationLower) ||
      restaurant.name.toLowerCase().includes(locationLower) ||
      restaurant.cuisineType.toLowerCase().includes(locationLower)
    );
  }
  
  // In a real application, we would check for actual availability based on reservations
  // For now, we'll just return the filtered restaurants
  return filteredRestaurants;
};

// Get all time slots for the reservation form
export const getAllTimeSlots = (): string[] => {
  return [
    '11:00', '11:30', 
    '12:00', '12:30', 
    '13:00', '13:30', 
    '14:00', '14:30',
    '17:00', '17:30',
    '18:00', '18:30', 
    '19:00', '19:30', 
    '20:00', '20:30',
    '21:00', '21:30'
  ];
};

// Get available time slots for a specific restaurant, date, and party size
export const getAvailableTimeSlots = (
  restaurant: Restaurant,
  date: string,
  partySize: number
): string[] => {
  const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'lowercase' });
  const hours = restaurant.openingHours[dayOfWeek];
  
  if (!hours) return [];
  
  const startTime = parseInt(hours.open.split(':')[0]);
  const endTime = parseInt(hours.close.split(':')[0]);
  
  // Generate all half-hour slots between opening and closing times
  const allTimeSlots = [];
  for (let hour = startTime; hour < endTime; hour++) {
    allTimeSlots.push(`${hour}:00`);
    if (hour + 0.5 < endTime) {
      allTimeSlots.push(`${hour}:30`);
    }
  }
  
  // In a real application, we would filter out already booked slots
  // For this mock, we'll randomly filter out some slots
  return allTimeSlots.filter(() => Math.random() > 0.3);
};
